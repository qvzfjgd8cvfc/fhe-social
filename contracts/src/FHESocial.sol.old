// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import {FHE, ebool, euint8, externalEuint8} from "@fhevm/solidity/lib/FHE.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title FHESocial
 * @dev FHE 加密留言板：用户可创建留言板，其他用户以密文提交留言，只有板主或留言者可解密查看。
 *      使用 fhEVM：密文字符数组 euint8[] 存储内容；支持密文点赞（0/1）。
 */
contract FHESocial is SepoliaConfig, Ownable, ReentrancyGuard {
    struct Board {
        address owner;
        string title;
        string description;
        bool allowAnonymous;
        uint8 maxLen; // 单条留言最大字节数（ASCII 上限）
        uint256 createdAt;
        bool exists;
    }

    struct Message {
        address author;
        uint256 timestamp;
        euint8[] content; // 密文字符数组（每个字符 1 字节）
        euint8 like;      // 0/1 密文点赞
    }

    uint256 public boardCount;
    mapping(uint256 => Board) public boards;
    mapping(uint256 => Message[]) private messages; // boardId => messages

    // 事件
    event BoardCreated(uint256 indexed boardId, address indexed owner, string title);
    event MessagePosted(uint256 indexed boardId, uint256 indexed msgId, address indexed author);
    event MessageLiked(uint256 indexed boardId, uint256 indexed msgId, address indexed user);

    // 错误
    error BoardNotFound();
    error NotBoardOwnerOrAuthor();
    error MessageNotFound();
    error ContentTooLong();
    error AnonymousNotAllowed();

    constructor() Ownable(msg.sender) {}

    // 创建留言板
    function createBoard(
        string calldata title,
        string calldata description,
        bool allowAnonymous,
        uint8 maxLen
    ) external returns (uint256 boardId) {
        boardId = ++boardCount;
        boards[boardId] = Board({
            owner: msg.sender,
            title: title,
            description: description,
            allowAnonymous: allowAnonymous,
            maxLen: maxLen == 0 ? 64 : maxLen, // 默认 64 字节
            createdAt: block.timestamp,
            exists: true
        });
        emit BoardCreated(boardId, msg.sender, title);
    }

    // 提交密文留言（批量 handle + 单一 proof）
    function postMessage(
        uint256 boardId,
        externalEuint8[] calldata contentHandles,
        bytes calldata proof
    ) external nonReentrant {
        Board memory b = boards[boardId];
        if (!b.exists) revert BoardNotFound();
        if (!b.allowAnonymous && msg.sender == address(0)) revert AnonymousNotAllowed();
        if (contentHandles.length == 0 || contentHandles.length > b.maxLen) revert ContentTooLong();

        euint8[] memory chars = new euint8[](contentHandles.length);
        for (uint256 i = 0; i < contentHandles.length; i++) {
            euint8 c = FHE.fromExternal(contentHandles[i], proof);
            FHE.allowThis(c);
            chars[i] = c;
        }

        // 初始化 like 为 0（密文）
        euint8 zero = FHE.asEuint8(0);
        FHE.allowThis(zero);

        messages[boardId].push(Message({
            author: msg.sender,
            timestamp: block.timestamp,
            content: chars,
            like: zero
        }));

        emit MessagePosted(boardId, messages[boardId].length - 1, msg.sender);
    }

    // 对留言点赞（传入密文 0/1），可重复更新
    function likeMessage(
        uint256 boardId,
        uint256 msgId,
        externalEuint8 likeHandle,
        bytes calldata proof
    ) external {
        if (!boards[boardId].exists) revert BoardNotFound();
        if (msgId >= messages[boardId].length) revert MessageNotFound();
        euint8 val = FHE.fromExternal(likeHandle, proof);
        FHE.allowThis(val);
        messages[boardId][msgId].like = val;
        emit MessageLiked(boardId, msgId, msg.sender);
    }

    // 仅板主或留言作者可重加密查看留言内容
    function reencryptMessage(
        uint256 boardId,
        uint256 msgId,
        bytes calldata publicKey
    ) external view returns (bytes[] memory) {
        Board memory b = boards[boardId];
        if (!b.exists) revert BoardNotFound();
        if (msgId >= messages[boardId].length) revert MessageNotFound();
        Message storage m = messages[boardId][msgId];
        if (msg.sender != b.owner && msg.sender != m.author) revert NotBoardOwnerOrAuthor();

        bytes[] memory out = new bytes[](m.content.length);
        for (uint256 i = 0; i < m.content.length; i++) {
            out[i] = FHE.reencrypt(m.content[i], publicKey);
        }
        return out;
    }

    // 重加密点赞值（0/1）
    function reencryptLike(
        uint256 boardId,
        uint256 msgId,
        bytes calldata publicKey
    ) external view returns (bytes memory) {
        Board memory b = boards[boardId];
        if (!b.exists) revert BoardNotFound();
        if (msgId >= messages[boardId].length) revert MessageNotFound();
        Message storage m = messages[boardId][msgId];
        if (msg.sender != b.owner && msg.sender != m.author) revert NotBoardOwnerOrAuthor();
        return FHE.reencrypt(m.like, publicKey);
    }

    // 公开元信息
    function getBoard(uint256 boardId) external view returns (
        address owner,
        string memory title,
        string memory description,
        bool allowAnonymous,
        uint8 maxLen,
        uint256 createdAt,
        uint256 messageCount
    ) {
        Board memory b = boards[boardId];
        if (!b.exists) revert BoardNotFound();
        return (b.owner, b.title, b.description, b.allowAnonymous, b.maxLen, b.createdAt, messages[boardId].length);
    }
}

